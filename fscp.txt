The FreeLAN Project                                         J. Kauffmann
Draft:                                                   www.freelan.org
Category: Informational                                    03 March 2011

                    The FreeLAN Secure Channel Protocol

Status of this Memo

   This memo provides information for the Internet community.  It does
   not specify an Internet standard of any kind.  Distribution of this
   memo is unlimited.

Abstract

   The FreeLAN peer-to-peer virtual private network specification
   requires a fast and secure communication channel.

   The protocol is specialized into peer-to-peer applications and
   supports some well-known NAT traversal techniques.

1. Introduction

   The FreeLAN peer-to-peer virtual private network specification
   requires a fast and secure communication channel.

   The FSCP (FreeLAN Secure Channel Protocol) is designed to be secure
   and efficient, and tries to minimize the overhead. It is based over
   UDP [RFC768].

   The protocol supports packet loss. Reordered or duplicated packets
   are treated as lost packets.

1.1. Terminology

   The keywords MUST, MUST NOT, REQUIRED, SHALL, SHALL NOT, SHOULD,
   SHOULD NOT, RECOMMENDED, MAY, and OPTIONAL, when they appear in this
   document, are to be interpreted as described in [RFC2119].

2. Format

   FSCP uses different message formats. The roles of these messages are
   described in a further section.

   Multi-bytes integer values MUST be written in network byte order.

2.1. Generic message format

   All messages start with a 4 bytes header whose layout is:

                  0      7 8     15 16    23 24    31
                 +--------+--------+-----------------+
                 |version |  type  |      length     |
                 +--------+--------+-----------------+

   The version MUST be set to the currently used version of the FreeLAN
   Secure Channel Protocol. The current version described in this
   document is 2.

   The type field indicates the type of the message. Its possible values
   are listed in the next sections.

   The length field indicates the length of the message body.

2.2. HELLO message format

   A HELLO message is 4 bytes long and has the following format:

                  0      7 8     15 16    23 24    31
                 +-----------------------------------+
                 |           unique_number           |
                 +-----------------------------------+

2.2.1. HELLO message type

   The type value of a HELLO message can be either:

     0x00: For a request HELLO message
     0x01: For a response HELLO message

2.2.2. HELLO message fields

   The unique_number field is a 4 bytes value chosen by the sender of a
   HELLO request message.

2.3. PRESENTATION message format

   A PRESENTATION message has the following format:

                  0      7 8     15 16    23 24    31
                 +-----------------+~~~~~~~~~~~~~~~~~+
                 |  sig_cert_len   |     sig_cert    |
                 +-----------------+~~~~~~~~~~~~~~~~~+
                 |  enc_cert_len   |     enc_cert    |
                 +-----------------+~~~~~~~~~~~~~~~~~+

2.3.1. PRESENTATION message type

   A PRESENTATION message has a type value of 0x02.

2.3.2. PRESENTATION message fields

   The sig_cert_len field indicates the size of the sig_cert field.

   The sig_cert field is a DER-encoded X509 certificate used for message
   signature by the sender. This certificate SHOULD have the
   digitalSignature key usage set, as specified in [RFC2459]. In the
   next sections, its associated RSA public and private keys for
   signature will respectively be referred as PKV and PKS.

   The enc_cert_len field indicates the size of the enc_cert field.

   The enc_cert field is a DER-encoded X509 certificate used for key
   exchange by the sender. This certificate SHOULD have the
   keyEncipherment key usage set, as specified in [RFC2459]. In the next
   sections, its associated RSA public and private keys for encryption
   will respectively be referred as PKE and PKD.

   If the same certificate is to be used for both usages, a sender MAY
   set enc_cert_len to zero and leave enc_cert empty. In this case, the
   certificate SHOULD have both digitalSignature and keyEncipherment key
   usage set, as specified in [RFC2459].

   However, it is RECOMMENDED that two different keys pairs be used for
   signature and encryption. A strict implementation MAY reject
   PRESENTATION messages with identicial signature and encryption
   certificates.

   The sig_cert and enc_cert certificates MUST have the exact same
   subjectName and issuerName. If they don't, the presentation message
   MUST be ignored.

   A host MIGHT ignore any PRESENTATION message whose sig_cert or
   enc_cert field does not satisfy the key usage requirements.

   The minimum RSA key size is 1024 bits. The RECOMMENDED RSA key size
   is 2048 bits or higher, with an exponent of 2^16 + 1. A strict
   implementation MAY reject PRESENTATION messages with a low RSA key
   size.

2.4. SESSION_REQUEST message format

   A SESSION_REQUEST message has the following format:

                  0      7 8     15 16    23 24    31
                 +-----------------------------------+
                 |          session_number           |
                 +~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~+
                 |          host_identifier          |
                 +~~~~~~~~~~~~~~~~~+~~~~~~~~~~~~~~~~~+
                 |   ec_cap_len    |      ec_cap     |
                 +-----------------+~~~~~~~~~~~~~~~~~+
                 |   kd_cap_len    |      kd_cap     |
                 +-----------------+~~~~~~~~~~~~~~~~~+
                 | cipher_cap_len  |    cipher_cap   |
                 +-----------------+~~~~~~~~~~~~~~~~~+

   This header is signed using the sender host signature private key
   (PKS).

   That is, a SESSION_REQUEST message sent over the wire has the
   following format:

                  0      7 8     15 16    23 24    31
                 +-----------------------------------+
                 |          session_number           |
                 +~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~+
                 |          host_identifier          |
                 +~~~~~~~~~~~~~~~~~+~~~~~~~~~~~~~~~~~+
                 |   ec_cap_len    |      ec_cap     |
                 +-----------------+~~~~~~~~~~~~~~~~~+
                 |   kd_cap_len    |      kd_cap     |
                 +-----------------+~~~~~~~~~~~~~~~~~+
                 | cipher_cap_len  |    cipher_cap   |
                 +-----------------+~~~~~~~~~~~~~~~~~+
                 |    ct_sig_len   |      ct_sig     |
                 +-----------------+~~~~~~~~~~~~~~~~~+

2.4.1. SESSION_REQUEST message type

   A SESSION_REQUEST message has a type value of 0x03.

2.4.2. SESSION_REQUEST message fields

   The session_number indicates the requested session number. If no
   previous session is known, session_number MUST be 0.

   The host_identifier field is 32 bytes long and is a random number
   generated on startup (or at least before a session attempt begins).

   It MUST remain constant during the lifetime of a FSCP client.

   The host_identifier can be different for every host the client wants
   to establish a session with, but MUST remain constant within that
   relationship.

   The ec_cap_len field indicates the length of the ec_cap field.

   The ec_cap field is a list of elliptic curves supported by the client,
   by order of preference.

   The kd_cap_len field indicates the length of the kd_cap field.

   The kd_cap field is a list of key derivation algorithm supported by
   the client, by order of preference.

   The cipher_cap_len field indicates the length of the cipher_cap field.

   The cipher_cap field is a list of cipher algorithms supported by the
   client, by order of preference.

   A list of identifiers for the elliptic curves, key derivation
   algorithms and cipher algorithms is available in a further section of
   this document.

   The ct_sig_len field indicates the length of the ct_sig field.

   The ct_sig field is the header signature, generated using the
   private signature key (PKS) of the sender host.

   A host who receives a SESSION_REQUEST message MUST first check if the
   ct_sig signature matches the sending host public verification key
   (PKV).

   If the signature does not match, the message MUST be ignored.

2.5. SESSION message format

   A SESSION message has the following format:

                  0      7 8     15 16    23 24    31
                 +-----------------------------------+
                 |          session_number           |
                 +~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~+
                 |          host_identifier          |
                 +~~~~~~~~~~~~~~~~~+~~~~~~~~~~~~~~~~~+
                 |   ec   |   kd   |  calg  | <zero> |
                 +-----------------+~~~~~~~~~~~~~~~~~+
                 |   pub_key_len   |     pub_key     |
                 +-----------------+~~~~~~~~~~~~~~~~~+
                 |nonce_prefix_len |  nonce_prefix   |
                 +-----------------+~~~~~~~~~~~~~~~~~+

   This header is signed using the sender host signature private key
   (PKS).

   That is, a SESSION message sent over the wire has the following
   format:

                  0      7 8     15 16    23 24    31
                 +-----------------------------------+
                 |          session_number           |
                 +~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~+
                 |          host_identifier          |
                 +~~~~~~~~~~~~~~~~~+~~~~~~~~~~~~~~~~~+
                 |   ec   |   kd   |  calg  | <zero> |
                 +-----------------+~~~~~~~~~~~~~~~~~+
                 |   pub_key_len   |     pub_key     |
                 +-----------------+~~~~~~~~~~~~~~~~~+
                 |nonce_prefix_len |  nonce_prefix   |
                 +-----------------+~~~~~~~~~~~~~~~~~+
                 |    ct_sig_len   |      ct_sig     |
                 +-----------------+~~~~~~~~~~~~~~~~~+

2.5.1. SESSION message type

   A SESSION message has a type value of 0x04.

2.5.2. SESSION message fields

   The session_number indicates the identifier of the session. Every
   session MUST have its own and unique session_number value.

   The host_identifier field is 32 bytes long and is a random number
   generated on startup (or at least before a session attempt begins).

   It MUST remain constant during the lifetime of a FSCP client.

   The host_identifier can be different for every host the client wants
   to establish a session with, but MUST remain constant within that
   relationship.

   The ec field is the code of the chosen elliptic curve. It MUST
   be the identifier of the first supported elliptic curve specified in
   the associated SESSION_REQUEST.

   The kd field is the code of the chosen key derivation algorithm. It
   MUST be the identifier of the first supported key derivation algorithm
   specified in the associated SESSION_REQUEST.

   The calg field is the code of the chosen cipher algorithm. It MUST
   be the identifier of the first supported cipher algorithm specified in
   the associated SESSION_REQUEST.

   A list of identifiers for the elliptic curves, key derivation
   algorithms and cipher algorithms is available in a further section of
   this document.

   A value of 0 in one of the ec, kd or calg fields indicates that none
   of the requested elliptic curve or algorithms are supported. In this
   case, the pub_key and nonce_prefix field SHOULD be empty.

   The <zero> field is reserved for future uses and MUST be zero in
   the current implementation.

   The pub_key_len field indicates the size of the pub_key field. It
   depends on the chosen elliptic curve.

   The pub_key field is a pub_key_len bytes long Elliptic Curve
   Diffie-Hellman Ephemeral public key generated by the host. It MUST be
   fed to the local ECDHE instance to generate the shared secret.

   Once generated, this shared secret is hashed using the key derivation
   algorithm both parties agreed on.

   The nonce_prefix_len indicates the size of the nonce_prefix field. It
   MUST be at least 8 bytes.

   The nonce_prefix field is a random value that will be prepended to
   the session and sequence number when generating the nonce.

   If the nonce_prefix received matches the local one, then the local MUST
   be regenerated until it is different. Failing to do so nullifies the
   security completely.

   The ct_sig_len field indicates the length of the ct_sig field.

   The ct_sig field is the header signature, generated using the
   private signature key (PKS) of the sender host.

   A host who receives a SESSION message MUST first check if the
   ct_sig signature matches the sending host public verification key (PKV).
   If the signature does not match, the message MUST be ignored.

   If an host receives a SESSION message whose ec, kd or calg is null, it
   SHOULD report to the upper layer that no session could be established
   with the requested parameters.

2.6. DATA message format

   A DATA message format has the following format:

                  0      7 8     15 16    23 24    31
                 +-----------------------------------+
                 |          sequence_number          |
                 +-----------------------------------+
                 |              tag...               |
                 +-----------------------------------+
                 |                ...                |
                 +-----------------------------------+
                 |                ...                |
                 +-----------------------------------+
                 |                ...                |
                 +~----------------+~~~~~~~~~~~~~~~~~+
                 |  ciphertext_len |    ciphertext   |
                 +-----------------+~~~~~~~~~~~~~~~~~+

2.6.1. DATA message type

   Valid type values for DATA messages are 0x70 to 0x7F.

   Every value represent a different channel. Those channels share the
   same session and thus, the same sequence numbers.

2.6.2. DATA message fields

   The sequence_number field indicates the sequence number of the
   current message. Two different DATA messages belonging to the same
   session MUST have two different sequence numbers. The rules governing
   the sequence number are explained in a further section.

   The tag field is 16 bytes long and contains the GCM tag associated to
   ciphertext.

   The ciphertext_len field is the length of the ciphertext field.

   The ciphertext field represents the data of the message, ciphered
   using the target host session cipher key.

   The nonce used for the generation of the ciphertext is a
   concatenation of the local nonce_prefix, the session_number and the
   sequence_number.

   The nonce used for the decipherment of the ciphertext is a
   concatenation of the remote nonce_prefix, the session_number and the
   sequence_number.

   If the decipherment of the ciphertext fails, the message MUST be
   ignored.

   The 4 less significant bits of the message type value indicate the
   channel number. The channel number SHOULD be made available to the
   upper layers.

2.7. CONTACT-REQUEST message format

   A CONTACT-REQUEST message is similar to a DATA message.

2.7.1. CONTACT-REQUEST message type

   A CONTACT-REQUEST message has a type value of 0xFD.

2.7.2. CONTACT-REQUEST message fields

   A CONTACT-REQUEST is similar to a DATA message.

   CONTACT-REQUEST and DATA messages share the same sequence counter.

   A host who receives a CONTACT-REQUEST message MUST also first check
   if the hmac matches the message. If the HMAC doesn't match, the
   message MUST be ignored.

   The data contained in a CONTACT-REQUEST message has the following
   format:

                  0      7 8     15 16    23 24    31
                 +-----------------------------------+
                 |               hash 0              |
                 +~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~+
                 |               hash 1              |
                 +~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~+
                 |                ...                |
                 +~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~+
                 |               hash n              |
                 +-----------------------------------+

   That is, a list of 32 bytes hashes indicating the certificate(s) for
   which contact addresses are requested.

   hash is 32 bytes long and is the SHA-256 digest of the DER
   representation of the requested certificate.

   Duplicates entries in the hash list MUST be treated like a single
   entry.

   The order of entries does not matter and CAN thus be ignored by the
   implementation.

2.8. CONTACT message format

   A CONTACT message is similar to a DATA message.

2.8.1. CONTACT message type

   A CONTACT message has a type value of 0xFE.

2.8.2. CONTACT message fields

   A CONTACT is similar to a DATA message.

   CONTACT and DATA messages share the same sequence counter.

   A host who receives a CONTACT message MUST also first check if the
   hmac matches the message. If the HMAC doesn't match, the message MUST be
   ignored.

   The data contained in a CONTACT message has the following format:

                  0      7 8     15 16    23 24    31
                 +-----------------------------------+
                 |               hash 0              |
                 +--------+~~~~~~~~~~~~~~~~~~~~~~~~~~+
                 | ep_type|         endpoint         |
                 +--------+~~~~~~~~~~~~~~~~~~~~~~~~~~+
                 |               hash 1              |
                 +--------+~~~~~~~~~~~~~~~~~~~~~~~~~~+
                 | ep_type|         endpoint         |
                 +--------+~~~~~~~~~~~~~~~~~~~~~~~~~~+
                 |                ...                |
                 +~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~+
                 |               hash n              |
                 +--------+~~~~~~~~~~~~~~~~~~~~~~~~~~+
                 | ep_type|         endpoint         |
                 +--------+~~~~~~~~~~~~~~~~~~~~~~~~~~+

   That is a list of (hash, ep_type, endpoint) tuples indicating the
   contact information for the specified hosts.

   hash is 32 bytes long and is the SHA-256 digest of the DER
   representation of the requested certificate.

   ep_type is a 1 byte field that can take the following values:

   * 0x04: IPv4 endpoint

   In which case, endpoint has the following format:

                  0      7 8     15 16    23 24    31
                 +-----------------------------------+
                 |            IPv4 address           |
                 +-----------------+-----------------+
                 |       port      |
                 +-----------------+

   * 0x06: IPv6 endpoint

   In which case, endpoint has the following format:

                  0      7 8     15 16    23 24    31
                 +-----------------------------------+
                 |            IPv6 address...        :
                 +-----------------+-----------------+
                 :         ...IPv6 address...        :
                 +-----------------+-----------------+
                 :         ...IPv6 address...        :
                 +-----------------+-----------------+
                 :         ...IPv6 address           |
                 +-----------------+-----------------+
                 |       port      |
                 +-----------------+

2.9. KEEP-ALIVE message format

   A KEEP-ALIVE message is similar to a DATA message.

2.9.1. KEEP-ALIVE message type

   A KEEP-ALIVE message has a type value of 0xFF.

2.9.2. KEEP-ALIVE message fields

   A KEEP-ALIVE is similar to a DATA message.

   KEEP-ALIVE and DATA messages share the same sequence counter.

   A host who receives a KEEP-ALIVE message MUST also first check if
   the hmac matches the message. If the HMAC doesn't match, the
   message MUST be ignored.

   The data contained in a KEEP-ALIVE message MUST be random to
   prevent key analysis attacks.

   The deciphered data SHOULD be ignored and not made accessible to the
   upper layers.

3. Algorithms

3.1. Symmetric cipherment algorithm

   The available elliptic curves used with ECDHE are:

   - 0x0D: SECT571K1
   - 0x0E: SECT571R1

   The available key derivation algorithms used with the ECDHE
   generated secret are:

   - 0x01: PBKDF2

   The available cipher algorithms used in the symmetric cipherment are:

   - 0x01: AES256-GCM.

   If an unknown cipher algorithm code is met, it must be ignored to
   account for implementation specific codes.

3.2. Asymmetric cipherment and signature algorithms

   The used signature algorithm is RSA with a PKCS#1 v2.1 PSS padding
   (RSASSA_PSS).

   The underlying hash algorithm is SHA256, the MGF method is
   MGF1-SHA256 and the salt length is equal to size of the SHA256
   message digest, that is, 32 bytes.

   The used encryption algorithm is RSA with a PKCS#1 v2.1 RSAES-OAEP
   padding.

   The underlying hash algorithm is SHA1 and the MGF method is
   MGF1-SHA1.

   The use of SHA1 here instead of SHA256 permits the encryption of
   SESSION messages with a RSA key of 1024 bits because of the reduced
   RSA padding size.

   The minimum key size is 1024. The RECOMMENDED key size is 2048.

3.3. Symmetric cipherment

   The DATA messages are ciphered using the chosen cipher algorithm.

   The key to use with that cipher is generated by applying the key
   derivation algorithm to the generated shared secret resulting for the
   ECDHE sequence. The size of that key depends on the chosen cipher
   algorithm.

4. Protocol

4.1. Saying "Hello"

   A host CAN test the protocol support of another host using a request
   HELLO message.

   A host who receives a request HELLO message MAY respond with a
   matching HELLO response message. The response message MUST have the
   same unique_number value.

   If a HELLO response is received that doesn't match with a recently
   send HELLO request, it MUST be ignored.

   The maximum amount of time to wait for a HELLO response is up to the
   implementor. A recommended value is 4 seconds.

   That is, the whole HELLO message functionality is OPTIONAL.

4.2. Presentation

   If two hosts want to communicate but don't "know" each other, they
   CAN send a PRESENTATION message to the remote host to inform them
   about their idendity.

   A host who receives a PRESENTATION message is free to ignore it if
   the presented certificates are not acceptable. Whether a certificate
   is acceptable or not is up to the host.

   A host MAY ignore any PRESENTATION message whose certificate does
   not match a previously sent certificate.

   That is, the whole PRESENTATION message functionality is OPTIONAL.

4.3. Sessions

   When a host wants to establish a session MUST send a SESSION_REQUEST
   message to the target host indicating the desired session number.

   When a host receives a SESSION_REQUEST or a SESSION message from an
   host, the following can happen:

   - If the message is the first one received from the host (that is,
   if no host_identifier is known for that host), the specified
   host_identifier is stored for later comparisons.
   - If the message host_identifier does not match the one known for
   the host, ignore it.
   - If the message host_identifier matches the one known for the host,
   continue to process it.

   When a session is lost (because of a timeout, or whenever the
   implementation decide a session is to be considered dead), the
   host_identifier known for the host SHOULD be emptied. This allows
   for session reestablishment with a given host that went down for
   some time (and thus changed his host_identifier).

   When receiving a SESSION_REQUEST message:

   - If no previous session exists with the requesting host, the target
   host and the parameters of the request are acceptable, the target
   host should generate a new ECDHE public key, a new nonce prefix and
   reply with a SESSION message containing those parameters.

   - If a previous session exists and the requested session number is
   higher than the current one, the target host should also generate a
   new ECDHE public key, a new nonce prefix and reply with a SESSION
   message containing those parameters.

   - If the requested session number is equal to or lower than the
   current one, the target host should reply with the same SESSION
   message that was used to establish the current session, except for
   the challenge that must match the one of the request.

   When receiving a SESSION message:

   - If the session number is higher than the current one, it should
   renew its session parameters and reply with an updated SESSION
   message that contains its new ECDHE public key as well as a new
   nonce prefix. The session is considered established on this
   receiving side.

   - If the session number, the public key, the algorithms and the
   nonce prefix match the current ones, the host MUST ignore it.

   - If the session number matches the current one, but the public
   key, the algorithms or the nonce prefix do not match the ones of the
  current session, it should send a SESSION_REQUEST with an incremented
  session number to start a new session.

   An existing session MUST remain valid until a new one completes to
   prevent DoS-replay attacks.

   If a host does not receive a response SESSION message after 3
   seconds, it MAY send another SESSION_REQUEST.

   If a host receives more than one request SESSION_REQUEST within 3
   seconds, it MAY only accept the first one and discard the others.

   If a session with the requesting host already exists and is not too
   old (more on that in the next sub-section), the target host MAY
   reply with the parameters from the current session.

   Whenever a session is established, its associated sequence number
   MUST be reset to zero.

4.3.1 Old sessions

   Every session has a limited lifespan. One host may send a maximum of
   2^16 data messages during a session.

   A session is considered old when a host considers too much data
   messages were sent during it. A good value for this "too much" is
   2^16 - 2^10 messages.

   Using a value too close from 2^16 may cause an interruption of the
   communication channel while new keys are being exchanged.

   Using a value too small would cause too many key exchange to occur.

   If a host receives a SESSION message with a session_number smaller
   than the last used session_number, it MUST discard the message.

   Note that in any case, the session lifespan is way smaller than the
   AES cipherment and sealing keys lifespan.

   A well designed implementation should however limit session renewals
   to a minimum since key exchange is a critical procedure.

4.3.2. Session timeout

   If an host does not receive any DATA or KEEP-ALIVE message from
   another host during 30 seconds, it SHOULD consider the session lost.

   After a session is lost, the hosts MUST renegotiate session keys
   before sending any DATA message.

4.4. DATA messages

   Once a host has the session parameters for a target host, it can
   start sending DATA messages to him.

   The sequence number of the first DATA message of a given session MUST
   be 1.

   The next sequence numbers must be greater than any previously used
   sequence number within the same session.

   If a host receives a DATA message with a sequence number lower than
   or equal to a previously received sequence number, it MUST ignore it.

4.5. CONTACT-REQUEST and CONTACT messages

   A host MAY send a CONTACT-REQUEST message for one or several
   certificates, to one or several hosts. A session MUST be established
   between the requesting host and the requested host.

   A host SHOULD NOT send a CONTACT-REQUEST message to a host for a
   certificate that is part of an active session (since a session is
   active, contact information for the certificate is already know and
   thus, sending a CONTACT-REQUEST for it is useless).

   A host receiving a CONTACT-REQUEST message CAN reply with one or
   several CONTACT messages.

   The receiving host SHOULD only reply to requests for which the
   requested certificate is known and used in an active session.

   If an host receives a request for its own certificate, it SHOULD
   discard it, but CAN still process other requests contained in the
   same CONTACT-REQUEST message.

4.6. KEEP-ALIVE messages

   If a host does not send any DATA message to another host within 10
   seconds, it SHOULD send a KEEP-ALIVE message to maintain the session
   alive.

5. Thanks

   Thanks to N.Caritey for his precious help regarding the security
   concerns and for his reviews of the present RFC.
